# -*- coding: utf-8 -*-
"""PREDICTIONS_strat1_h2o

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1_7wOAP-39Ov7RXACsn9MRRB6pIDHnSVq
"""

! pip install h2o --quiet
import numpy as np
import pandas as pd
import h2o
from h2o.automl import H2OAutoML
from sklearn.utils import shuffle
from sklearn.model_selection import train_test_split
import math
import itertools as itt
from typing import Generator, Tuple, List, Dict
import matplotlib.pyplot as plt
import seaborn as sns
import os
import glob
import pickle
pd.set_option('display.float_format', '{:.12f}'.format)
import scipy.stats as ss

h2o.init(verbose=False)
h2o.no_progress()

def calc_sharpe_daily(daily_pnl: pd.Series) -> float:
    mean_daily = daily_pnl.mean()
    std_daily = daily_pnl.std()
    if std_daily == 0.0:
        return 0.0
    return mean_daily / std_daily

model_rankings_input_directory = '/content/drive/MyDrive/1. learning/1datasci/financial ML/project 1. backtest overfitting forex/results_forex/BESTMODELS_strat1_h2o'

"""to see all models"""

all_currency_sharpe = {}

# Loop through all CSV files in the directory
for filename in os.listdir(model_rankings_input_directory):
    currency = filename.split('_')[0]  # Extract currency name from filename
    file_path = os.path.join(model_rankings_input_directory, filename)

    # Load the CSV file into a DataFrame
    df = pd.read_csv(file_path)

    # Store the DataFrame in the dictionary
    all_currency_sharpe[currency] = df

# Assuming all_currency_sharpe dictionary is already populated

for curr, df in all_currency_sharpe.items():  # Use items() to iterate over key-value pairs
    print(f"\nCurrency: {curr}")  # Print the currency name
    display(df)  # Display the DataFrame for that currency

"""to see only the best models"""

CUT_OFF = 5 # SELECT CUT OFF FOR NUMBER OF MODELS CHOSEN
selected_models = {}

# Loop through all currency DataFrames in the dictionary
for currency, df in all_currency_sharpe.items():
    # Initialize a dictionary to hold selected models for the current currency
    selected_models[currency] = {}

    # Group by 'cv_method' and select the top models according to 'average_sharpe'
    for cv_method, group in df.groupby('cv_method'):
        top_models = group.nlargest(CUT_OFF, 'average_sharpe')
        selected_models[currency][cv_method] = top_models[['model', 'average_sharpe']].reset_index(drop=True)

# Print the selected models for each currency categorized by CV method
for currency, models in selected_models.items():
    print(f"\nCurrency: {currency}")
    for cv_method, model_df in models.items():
        print(f"\n  {cv_method}")
        display(model_df)

currency_input_directory = '/content/drive/MyDrive/1. learning/1datasci/financial ML/project 1. backtest overfitting forex/results_forex/LABELS_strat1'

feature_files = glob.glob(os.path.join(currency_input_directory, "*_features.csv"))

currency_data = {}

for file in feature_files:
    currency = os.path.basename(file).split('_')[0]
    print(f"currency: {currency}")

    features = pd.read_csv(f"{currency_input_directory}/{currency}_features.csv", index_col=0)
    target = pd.read_csv(f"{currency_input_directory}/{currency}_target.csv", index_col=0)
    close = pd.read_csv(f"{currency_input_directory}/{currency}_close.csv", index_col=0)
    times = pd.read_csv(f"{currency_input_directory}/{currency}_times.csv", index_col=0)
    features.index = pd.to_datetime(features.index, format='mixed')
    times.index = pd.to_datetime(times.index)
    close.index = pd.to_datetime(close.index)
    target.index = pd.to_datetime(target.index)
    print(len(features), len(target), len(close), len(times))

    features_train, features_test, target_train, target_test = train_test_split(
        features, target, train_size=0.7, shuffle=False)
    train = pd.concat([features_train, target_train], axis=1)
    test = pd.concat([features_test, target_test], axis=1)

    currency_data[currency] = {
        'test': test,
        'features': features,
        'target': target,
        'close': close,
        'times': times
    }

all_models_directory = '/content/drive/MyDrive/1. learning/1datasci/financial ML/project 1. backtest overfitting forex/results_forex/ALLMODELS_strat1_h2o'

def load_model_paths_with_currency(directory: str, selected_models: dict) -> dict:
    models = {}

    for model_name in os.listdir(directory):
        currency = model_name.split('_')[0]
        model_path = os.path.join(directory, model_name)

        if currency in selected_models:
            for cv_method, model_df in selected_models[currency].items():
                if model_name in model_df['model'].values:
                    if currency not in models:
                        models[currency] = {}
                    if cv_method not in models[currency]:
                        models[currency][cv_method] = []

                    models[currency][cv_method].append(model_path)

    return models

model_paths = load_model_paths_with_currency(all_models_directory, selected_models)
for currency, cv_methods in model_paths.items():
    print(f"\ncurrency: {currency}")
    for cv_method, paths in cv_methods.items():
        print(f"  cv method: {cv_method}")
        for path in paths:
            print(f"    path: {path}")

output_directory = '/content/drive/MyDrive/1. learning/1datasci/financial ML/project 1. backtest overfitting forex/results_forex/PREDICTIONS_strat1_h2o'

def predict_on_test_set_h2o(test_set, close, model_paths):
    results = {}

    for model_path in model_paths:
        model = h2o.load_model(model_path)
        model_id = model.model_id

        test_set_h2o = h2o.H2OFrame(test_set)
        predictions = model.predict(test_set_h2o).as_data_frame(use_multi_thread=True)

        predicted_class = pd.Series(predictions["predict"].values, index=test_set.index)
        positions = pd.Series(np.where(predicted_class == 1, 1,
                                       np.where(predicted_class == -1, -1, 0)),
                              index=test_set.index)

        close_indexed = close.reindex(test_set.index).squeeze()

        strat_returns = (close_indexed.diff() * positions.shift()).fillna(0)
        daily_pnl = strat_returns.resample("D").sum()
        results[model_id] = {"daily_pnl": daily_pnl}

        non_annualised_sharpe = calc_sharpe_daily(daily_pnl)

        print(f"    {model_id} - non annualised sharpe: {non_annualised_sharpe:.4f} - annualised: {non_annualised_sharpe*np.sqrt(252):.4f}")

        results[model_id].update({
            "sharpe": non_annualised_sharpe
        })

    return results

predictions_results = {}

for currency, cv_methods in selected_models.items():
    print(f"\n===========================\n currency: {currency}\n===========================")

    predictions_results[currency] = {}

    for cv_method, model_df in cv_methods.items():
        print(f"  cv method: {cv_method}")

        model_names = set(model_df['model'].values)

        filtered_model_paths = [
            path for path in model_paths.get(currency, {}).get(cv_method, [])
            if os.path.basename(path) in model_names
        ]

        test_set = currency_data[currency]['test']
        close_prices = currency_data[currency]['close']

        if filtered_model_paths:
            results = predict_on_test_set_h2o(test_set, close_prices, filtered_model_paths)
            predictions_results[currency][cv_method] = results

predictions_output_directory = '/content/drive/MyDrive/1. learning/1datasci/financial ML/project 1. backtest overfitting forex/results_forex/PREDICTIONS_strat1_h2o'
output_file_path = os.path.join(predictions_output_directory, 'predictions_results.pkl')

with open(output_file_path, 'wb') as f:
    pickle.dump(predictions_results, f)