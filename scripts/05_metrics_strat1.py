# -*- coding: utf-8 -*-
"""METRICS_strat1_h2o

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1ZBZp8RUQiiiQ-o0wM036EoehFwqkLL6q
"""

import numpy as np
import pandas as pd
import scipy.stats as ss
from scipy.stats import norm
import math
import itertools as itt
from typing import Generator, Tuple, List, Dict
import matplotlib.pyplot as plt
import seaborn as sns
import os
import glob
import pickle
sns.set_style('dark')

def calc_sharpe_daily(pnl: pd.Series) -> float:
    daily_pnl = pnl.resample("D").sum()
    mean_daily = daily_pnl.mean()
    std_daily = daily_pnl.std()
    if std_daily == 0.0:
        return 0.0
    return mean_daily / std_daily

predictions_input_directory = '/content/drive/MyDrive/1. learning/1datasci/financial ML/project 1. backtest overfitting forex/results_forex/PREDICTIONS_strat1_h2o'
input_file_path = os.path.join(predictions_input_directory, 'predictions_results.pkl')

with open(input_file_path, 'rb') as f:
    predictions_results = pickle.load(f)

output_directory = '/content/drive/MyDrive/1. learning/1datasci/financial ML/project 1. backtest overfitting forex/results_forex/METRICS_strat1_h2o'

"""---
# DEFLATED SHARPE
"""

def benchmark_sharpe(sharpe_ratio_estimates: list) -> float:
    standard_deviation = np.array(sharpe_ratio_estimates).std()
    benchmark_value = standard_deviation * (
        (1 - np.euler_gamma) * ss.norm.ppf(1 - 1 / len(sharpe_ratio_estimates))
        + np.euler_gamma * ss.norm.ppf(
            1 - 1 / len(sharpe_ratio_estimates) * np.e ** (-1)
        )
    )

    return benchmark_value

def deflated_sharpe(
    observed_sharpe_ratio: float,
    benchmark_sharpe_ratio: float,
    number_of_returns: int,
    skewness_of_returns: float = 0,
    kurtosis_of_returns: float = 3,
) -> float:
    numerator = (observed_sharpe_ratio - benchmark_sharpe_ratio) * np.sqrt(number_of_returns - 1)
    denominator = (1 - skewness_of_returns * observed_sharpe_ratio + (kurtosis_of_returns - 1) / 4 * observed_sharpe_ratio**2) ** 0.5
    test_value = numerator / denominator
    return ss.norm.cdf(test_value)

def calc_deflated_sharpe(results_test_set):
    all_sharpes = [model_results["sharpe"] for model_results in results_test_set.values()]
    benchmark = benchmark_sharpe(all_sharpes)

    highest_sharpe = max(all_sharpes)
    highest_sharpe_model = None
    strat_returns = None

    for model_id, model_results in results_test_set.items():
        if model_results["sharpe"] == highest_sharpe:
            highest_sharpe_model = model_id
            strat_returns = model_results["daily_pnl"]

    number_of_returns = len(strat_returns)
    skewness_of_returns = strat_returns.skew()
    kurtosis_of_returns = strat_returns.kurtosis()
    # print(f'         all_sharpes: {all_sharpes}')
    # print(f"         benchmark (SR_0) (non-annualised): {benchmark}")
    # print(f"         best sharpe: {highest_sharpe} - from model: {highest_sharpe_model}")
    # print(f"         skewness of returns (y3): {skewness_of_returns}")
    # print(f"         kurtosis of returns (y4): {kurtosis_of_returns}")
    # print(f"         length of returns (T): {number_of_returns}")

    dsr = deflated_sharpe(
        observed_sharpe_ratio=highest_sharpe,
        benchmark_sharpe_ratio=benchmark,
        number_of_returns=number_of_returns,
        skewness_of_returns=skewness_of_returns,
        kurtosis_of_returns=kurtosis_of_returns,
    )
    return dsr

dsr_results = {}

for currency, cv_methods in predictions_results.items():
    dsr_results[currency] = {}
    print(f"\n===========================\n currency: {currency}\n===========================")

    for cv_method, models in cv_methods.items():
        dsr = calc_deflated_sharpe(models)
        print(f" {dsr:.6f} - {cv_method}")
        dsr_results[currency][cv_method] = dsr

dsr_output_path = os.path.join(output_directory, 'dsr_results.pkl')
with open(dsr_output_path, 'wb') as f:
    pickle.dump(dsr_results, f)

"""---
# PROB OF BACKTEST OVERFITTING
"""

def calc_pbo(model_data, S):
    # 1
    M = pd.DataFrame({model: data['daily_pnl'] for model, data in model_data.items()})

    # 2
    submatrices = [M.iloc[i::S, :] for i in range(S)]

    # 3
    combinations_size = S // 2
    combinations_indices = list(itt.combinations(range(S), combinations_size))

    # print(f"\nStep 2: Partitioned into {S} submatrices.")
    # for idx, submatrix in enumerate(submatrices):
    #     print(f"\nSubmatrix {idx + 1}:")
    #     display(submatrix.head())
    #     print(f"Shape: {submatrix.shape}\n")
    # print(f"{len(combinations_indices)} combinations")

    # 4
    logits = []
    for comb in combinations_indices:
        J_train = pd.concat([submatrices[i] for i in comb], axis=0)
        J_test = pd.concat([submatrices[i] for i in range(S) if i not in comb], axis=0)

        # 4c
        Rc_IS = J_train.mean()  # Mean performance as metric
        Rc_OOS = J_test.mean()  # Mean performance as metric

        # 4e
        n_star = Rc_IS.idxmax()

        # 4f
        rank_OOS = Rc_OOS.rank(ascending=False)[n_star]
        omega_c = rank_OOS / (N + 1)

        # 4g
        logit_lambda_c = np.log(omega_c / (1 - omega_c))
        logits.append(logit_lambda_c)

        # print(f"IS performance:{Rc_IS}")
        # print(f"OOS performance:{Rc_OOS}")
        # print(f"best performing strat IS: {n_star}")
        # print(f"relative rank ω̄c: {omega_c}")
        # print(f"logit λc: {logit_lambda_c}")

    # logit to pbo
    failures = sum(1 for logit in logits if logit <= 0)
    pbo = failures / len(logits)
    return pbo

S = 4
pbo_results = {}

for currency, cv_methods in predictions_results.items():
    print(f"\n===========================\n currency: {currency}\n===========================")

    pbo_results[currency] = {}
    for cv_method, model_data in cv_methods.items():
        pbo_value = calc_pbo(model_data, S)
        print(f" {pbo_value:.6f} - {cv_method}")
        pbo_results[currency][cv_method] = pbo_value

pbo_output_path = os.path.join(output_directory, 'pbo_results.pkl')
with open(pbo_output_path, 'wb') as f:
    pickle.dump(pbo_results, f)

def dict_to_df(results_dict, metric_name):
    df_list = []
    for currency, methods in results_dict.items():
        for method, value in methods.items():
            df_list.append({'currency': currency, 'cv method': method, 'value': value, 'metric': metric_name})
    return pd.DataFrame(df_list)

dsr_df = dict_to_df(dsr_results, 'DSR')
pbo_df = dict_to_df(pbo_results, 'PBO')
df = pd.concat([dsr_df, pbo_df], ignore_index=True)

def plot_metric(df, metric_name):
    plt.figure(figsize=(8, 4))
    sns.boxplot(x='cv method', y='value', data=df, palette='rocket', hue='cv method', width=0.2)
    plt.title(f"\n{metric_name}")
    plt.ylabel(metric_name)
    plt.xlabel('')
    plt.tight_layout();

metrics_to_plot = [
    (dsr_df, 'DSR'),
    (pbo_df, 'PBO')
]

for df, metric in metrics_to_plot:
    plot_metric(df, metric)